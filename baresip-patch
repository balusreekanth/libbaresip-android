diff --git a/modules/account/account.c b/modules/account/account.c
index 3055e396..79dfd505 100644
--- a/modules/account/account.c
+++ b/modules/account/account.c
@@ -155,21 +155,15 @@ static int line_handler(const struct pl *addr, void *arg)
 	/* prompt password if auth_user is set, but auth_pass is not  */
 	if (str_isset(account_auth_user(acc)) &&
 	    !str_isset(account_auth_pass(acc))) {
-		char *pass = NULL;
 
-		(void)re_printf("Please enter password for %s: ",
-				account_aor(acc));
+		char password[64];
 
-		err = ui_password_prompt(&pass);
-		if (err)
-			goto out;
-
-		err = account_set_auth_pass(acc, pass);
+		ua_event((struct ua *)account_aor(acc), UA_EVENT_CUSTOM,
+			 (struct call *)password, "password");
 
-		mem_deref(pass);
+		err = account_set_auth_pass(acc, password);
 	}
 
- out:
 	return err;
 }
 
diff --git a/src/ua.c b/src/ua.c
index b5e63a44..acd92651 100644
--- a/src/ua.c
+++ b/src/ua.c
@@ -83,6 +83,64 @@ void ua_printf(const struct ua *ua, const char *fmt, ...)
 }
 
 
+static void add_extension(struct ua *ua, const char *extension)
+{
+	struct pl e;
+
+	if (ua->extensionc >= ARRAY_SIZE(ua->extensionv)) {
+		warning("ua: maximum %zu number of SIP extensions\n",
+			ARRAY_SIZE(ua->extensionv));
+		return;
+	}
+
+	pl_set_str(&e, extension);
+
+	ua->extensionv[ua->extensionc++] = e;
+}
+
+
+static int create_register_clients(struct ua *ua)
+{
+	int err = 0;
+
+	/* Register clients */
+	if (uag_cfg() && str_isset(uag_cfg()->uuid))
+		add_extension(ua, "gruu");
+
+	if (0 == str_casecmp(ua->acc->sipnat, "outbound")) {
+
+		size_t i;
+
+		add_extension(ua, "path");
+		add_extension(ua, "outbound");
+
+		if (!str_isset(uag_cfg()->uuid)) {
+
+			warning("ua: outbound requires valid UUID!\n");
+			err = ENOSYS;
+			goto out;
+		}
+
+		for (i=0; i<ARRAY_SIZE(ua->acc->outboundv); i++) {
+
+			if (ua->acc->outboundv[i] && ua->acc->regint) {
+				err = reg_add(&ua->regl, ua, (int)i+1);
+				if (err)
+					break;
+			}
+		}
+	}
+	else if (ua->acc->regint) {
+		err = reg_add(&ua->regl, ua, 0);
+	}
+
+	add_extension(ua, "replaces");
+
+ out:
+	return err;
+}
+
+
 static int start_register(struct ua *ua, bool fallback)
 {
 	struct account *acc;
@@ -135,7 +193,10 @@ static int start_register(struct ua *ua, bool fallback)
 		}
 	}
 
-	if (!fallback)
+	if (list_isempty(&ua->regl))
+		create_register_clients(ua);
+
+	if (!fallback && !list_isempty(&ua->regl))
 		ua_event(ua, UA_EVENT_REGISTERING, NULL, NULL);
 
 	for (le = ua->regl.head, i=0; le; le = le->next, i++) {
@@ -838,64 +899,6 @@ void ua_handle_options(struct ua *ua, const struct sip_msg *msg)
 }
 
 
-static void add_extension(struct ua *ua, const char *extension)
-{
-	struct pl e;
-
-	if (ua->extensionc >= ARRAY_SIZE(ua->extensionv)) {
-		warning("ua: maximum %zu number of SIP extensions\n",
-			ARRAY_SIZE(ua->extensionv));
-		return;
-	}
-
-	pl_set_str(&e, extension);
-
-	ua->extensionv[ua->extensionc++] = e;
-}
-
-
-static int create_register_clients(struct ua *ua)
-{
-	int err = 0;
-
-	/* Register clients */
-	if (uag_cfg() && str_isset(uag_cfg()->uuid))
-		add_extension(ua, "gruu");
-
-	if (0 == str_casecmp(ua->acc->sipnat, "outbound")) {
-
-		size_t i;
-
-		add_extension(ua, "path");
-		add_extension(ua, "outbound");
-
-		if (!str_isset(uag_cfg()->uuid)) {
-
-			warning("ua: outbound requires valid UUID!\n");
-			err = ENOSYS;
-			goto out;
-		}
-
-		for (i=0; i<ARRAY_SIZE(ua->acc->outboundv); i++) {
-
-			if (ua->acc->outboundv[i] && ua->acc->regint) {
-				err = reg_add(&ua->regl, ua, (int)i+1);
-				if (err)
-					break;
-			}
-		}
-	}
-	else if (ua->acc->regint) {
-		err = reg_add(&ua->regl, ua, 0);
-	}
-
-	add_extension(ua, "replaces");
-
- out:
-	return err;
-}
-
-
 static const char *autoans_header_name(enum answer_method met)
 {
 	switch (met) {
